<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Minecraft Voice Proxy</title>
  <style>
    body { 
      font-family: system-ui, sans-serif; 
      padding: 20px; 
      max-width: 400px; 
      margin: 0 auto;
      background: #1a1a1a;
      color: #ffffff;
    }
    .container {
      background: #2a2a2a;
      border-radius: 8px;
      padding: 20px;
      text-align: center;
    }
    h1 {
      margin: 0 0 16px 0;
      color: #4CAF50;
      font-size: 1.5em;
    }
    .status {
      background: #333;
      padding: 12px;
      border-radius: 6px;
      margin: 16px 0;
      border-left: 4px solid #4CAF50;
    }
    .status.listening {
      border-left-color: #FF5722;
      background: #2d1b1b;
    }
    .status.error {
      border-left-color: #f44336;
      background: #2d1b1b;
    }

  </style>
</head>
<body>
  <div class="container">
    <h1>ðŸŽ¤ Voice Proxy</h1>
    <div id="status" class="status">Connecting...</div>
  </div>

<script>
(() => {
  // ====== CONFIG ======
  let lang = "en-US";
  // Array of entries: { phrase: string, name: string }
  let spells = [];
  let isListening = false;
  
  const params = new URLSearchParams(location.search);
  const wsPort = Number(params.get("wsPort") || "8765");
  const WS_URL = `ws://127.0.0.1:${wsPort}/bridge`;

  // DOM elements
  const statusEl = document.getElementById("status");

  // ====== WS BRIDGE ======
  let ws;
  function send(msg) { 
    if (ws && ws.readyState === 1) {
      ws.send(JSON.stringify(msg)); 
    }
  }
  
  function connectWS() {
    ws = new WebSocket(WS_URL);
    ws.onopen = () => {
      setStatus("Connected - Starting microphone...");
      // Auto-start speech recognition once connected
      startRecognition();
      setStatus("Connected");
    };
    
    ws.onmessage = (evt) => {
      const msg = JSON.parse(evt.data || "{}");
      console.log("[Voice Debug] Received message:", msg);
      
      if (msg["type"] === "config") {
        console.log("[Voice Debug] Config received - lang:", msg.lang, "spells:", msg.spells);
        if (msg.lang) lang = msg.lang;
        console.log("[Voice Debug] Lang:", lang);
        if (Array.isArray(msg.spells)) {
          // Expect array of { phrase, name }
          console.log("[Voice Debug] Updated spells array:", msg.spells);
          spells = msg.spells.filter(s => s && typeof s.phrase === 'string' && typeof s.name === 'string');
          // No need to restart - just update the spell list
        }
      } else if (msg["type"] === "start") {
        startRecognition();
      } else if (msg["type"] === "stop") {
        stopRecognition();
      }
    };
    
    ws.onclose = () => { 
      setStatus("Reconnecting...", false); 
      setTimeout(connectWS, 1000); 
    };
    
    ws.onerror = () => setStatus("Connection error", true);
  }
  connectWS();

  // ====== SPEECH RECOGNITION ======
  const SR = window.SpeechRecognition || window.webkitSpeechRecognition;

  let recog = null;

  function setStatus(text, isError = false) { 
    statusEl.textContent = text; 
    statusEl.style.color = isError ? "#ff4444" : "#ffffff";
  }

  // ===================== Normalization helpers =====================

  /**
   * normalize(s)
   *  - Lowercase
   *  - Keep letters (aâ€“z), digits (0â€“9), spaces, and apostrophes.
   *    The regex /[^a-z0-9\s']/g matches any character NOT in that set and
   *    replaces it with a single space.
   *  - Collapse multiple spaces -> one space
   *  - Trim leading/trailing spaces
   */
  function normalize(s) {
    return String(s)
      .toLowerCase()
      .replace(/[^a-z0-9\s']/g, " ") // keep a-z, 0-9, spaces, apostrophes
      .replace(/\s+/g, " ")          // collapse runs of whitespace
      .trim();
  }

  /** tokenize(s): normalize + split on single spaces */
  function tokenize(s) {
    const n = normalize(s);
    return n ? n.split(" ") : [];
  }

  /** joinTokens(tokens): join tokens with single spaces to compare phrases */
  function joinTokens(toks) {
    return toks.join(" ");
  }

  // ===================== Levenshtein distance =====================
  
  function levenshtein(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    
    const matrix = [];
    for (let i = 0; i <= b.length; i++) {
      matrix[i] = [i];
    }
    for (let j = 0; j <= a.length; j++) {
      matrix[0][j] = j;
    }
    
    for (let i = 1; i <= b.length; i++) {
      for (let j = 1; j <= a.length; j++) {
        if (b.charAt(i - 1) === a.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1, // substitution
            matrix[i][j - 1] + 1,     // insertion
            matrix[i - 1][j] + 1      // deletion
          );
        }
      }
    }
    
    return matrix[b.length][a.length];
  }

  // ===================== Core matching logic =====================

  const MAX_EDITS = 1; // Allow at most 1 total character edit (sub/ins/del)

  /**
   * tryMatchSpan(spanTokens, spellNorm)
   *  - spanTokens: contiguous tokens from the HEARD text (already normalized)
   *  - spellNorm:  normalized spell string (spaces preserved)
   *
   * Checks two things:
   *   1) No-merge: span tokens as-is vs spell (<= MAX_EDITS)
   *   2) Single-merge: try compacting exactly ONE adjacent pair inside the span
   *      (remove the space between tokens[j] and tokens[j+1]) and compare (<=1 edit).
   *
   * Returns true if either passes, false otherwise.
   */
  function tryMatchSpan(spanTokens, spellNorm) {
    // 1) No merge
    const phrase = joinTokens(spanTokens);
    if (levenshtein(phrase, spellNorm) <= MAX_EDITS) return true;

    // 2) Exactly one adjacent merge (remove the space once)
    if (spanTokens.length >= 2) {
      for (let j = 0; j < spanTokens.length - 1; j++) {
        const merged = [
          ...spanTokens.slice(0, j),
          spanTokens[j] + spanTokens[j + 1], // compact these two
          ...spanTokens.slice(j + 2)
        ];
        const mergedPhrase = joinTokens(merged);
        if (levenshtein(mergedPhrase, spellNorm) <= MAX_EDITS) return true;
      }
    }

    return false;
  }

  /**
   * matchSpell(heard, spells, alts = [])
   *  - heard: top transcript string from ASR
   *  - spells: array of spell strings (may be 1+ words)
   *  - alts: optional n-best hypotheses (each with {text|transcript})
   *
   * Returns the matched spell string or null. Binary decision â€” match or not.
   *
   * Rules:
   *  - Never modify/compact the spell text.
   *  - Only compact ONE adjacent pair in the HEARD phrase (tested exhaustively).
   *  - For a spell with m tokens, we only consider heard spans of length m (no-merge)
   *    and length m+1 (one merge reduces it back to m).
   */
  function matchSpell(heard, spells, alts = []) {
    const hyps = [heard, ...alts.map(a => a.text || a.transcript).filter(Boolean)];

    // Pre-normalize spells once
    const spellInfos = spells.map(s => {
      const norm = normalize(s);
      return { orig: s, norm, tokens: norm ? norm.split(" ") : [] };
    });

    for (const hyp of hyps) {
      const heardTokens = tokenize(hyp);
      if (!heardTokens.length) continue;

      for (const sp of spellInfos) {
        const m = sp.tokens.length;
        if (m === 0) continue;

        // A) spans of length m (no-merge path allowed inside tryMatchSpan)
        for (let i = 0; i + m <= heardTokens.length; i++) {
          const span = heardTokens.slice(i, i + m);
          if (tryMatchSpan(span, sp.norm)) return sp.orig;
        }

        // B) spans of length m+1 (exactly one merge will reduce to m)
        for (let i = 0; i + m + 1 <= heardTokens.length; i++) {
          const span = heardTokens.slice(i, i + m + 1);
          if (tryMatchSpan(span, sp.norm)) return sp.orig;
        }
      }
    }

    return null;
  }

  function stopRecognition() { 
    try { 
      if (recog) {
        recog.abort();
      }
    } catch (e) {
      console.log("[Voice Debug] Error stopping recognition:", e);
    } 
    isListening = false;
    setStatus("Stopped");
  }

  function startRecognition() {
    if (!SR) { 
      setStatus("Speech recognition not supported", true);
      return; 
    }
    
    if (!recog) {
      recog = new SR();
      recog.continuous = true;
      recog.interimResults = false;  // Only final results
      recog.lang = lang;

      recog.onresult = (e) => {
        for (let i = e.resultIndex; i < e.results.length; i++) {
          const result = e.results[i];
          if (result.isFinal) {
            const heard = result[0].transcript.trim();
            const alts = [];
            for (let k = 0; k < result.length; k++) {
              alts.push({ text: result[k].transcript, confidence: result[k].confidence ?? null });
            }
            
            console.log("heard", heard, "spells", spells, "alts", alts);
            // Match against phrases, then map to the spell name to send back
            const phrases = spells.map(s => s.phrase);
            const matchedPhrase = matchSpell(heard, phrases, alts);
            if (matchedPhrase) {
              const entry = spells.find(s => s.phrase === matchedPhrase);
              const spellName = entry ? entry.name : matchedPhrase;
              send({ type: "spellCast", spellName });
            }
          }
        }
      };

      recog.onstart = () => {
        isListening = true;
        setStatus(`Listening (${lang})`);
      };

      recog.onend = () => {
        if (isListening) {
          setTimeout(() => { 
            try { 
              if (isListening) recog.start(); 
            } catch {} 
          }, 200);
        }
      };

      recog.onerror = (e) => {
        if (e.error === 'not-allowed') {
          setStatus("Microphone permission denied - please allow and refresh", true);
          isListening = false;
        }
      };
    }

    recog.lang = lang;
    try { 
      recog.start(); 
    } catch (e) {
      console.log("[Voice Debug] Error starting recognition:", e);
      setStatus("Failed to start listening", true);
    }
  }



  // Auto-start when page loads
  // Speech recognition will start automatically when WebSocket connects
})();
</script>
</body>
</html> 
